{
  "version": 3,
  "sources": ["../../src/tools/convert-media.ts", "../../src/utils/converter.ts", "../../src/utils/ffmpeg.ts", "../../src/utils/exec.ts", "../../src/types/media.ts"],
  "sourcesContent": ["import { convertMedia } from \"../utils/converter\";\nimport {\n  type QualitySettings,\n  type QualityLevel,\n  type OutputImageExtension,\n  type OutputAudioExtension,\n  type OutputVideoExtension,\n  /* type AllOutputExtension, */\n  type ImageQuality,\n  type AudioQuality,\n  type VideoQuality,\n  getMediaType,\n  DEFAULT_QUALITIES,\n  // Advanced controls & helpers\n  AUDIO_BITRATES,\n  AUDIO_SAMPLE_RATES,\n  AUDIO_BIT_DEPTH,\n  AUDIO_PROFILES,\n  AUDIO_COMPRESSION_LEVEL,\n  VIDEO_ENCODING_MODES,\n  VIDEO_BITRATE,\n  VIDEO_MAX_BITRATE,\n  VIDEO_PRESET,\n  PRORES_VARIANTS,\n  VP9_QUALITY,\n  SIMPLE_QUALITY_MAPPINGS,\n} from \"../types/media\";\nimport { findFFmpegPath } from \"../utils/ffmpeg\";\nimport { Tool } from \"@raycast/api\";\nimport path from \"path\";\nimport os from \"os\";\nimport fs from \"fs\";\n\nasync function getFullPath(inputPath: string | undefined) {\n  // Validate that we actually received an input path. Safeguards against runtime errors such as\n  // \"Cannot read properties of undefined (reading 'replace')\" when the tool is invoked without\n  // an argument.\n  if (!inputPath) {\n    throw new Error(\"Input path is required but was not provided.\");\n  }\n\n  const fullPath = path.resolve(path.normalize(inputPath.replace(/^~/, os.homedir())));\n\n  if (!fs.existsSync(fullPath)) {\n    throw new Error(`The file does not exist at ${fullPath}`);\n  }\n\n  return fullPath;\n}\n\ntype Input = {\n  inputPath: string;\n  // I cannot, for the life of me, figure out how to get the type of this array to be a union of its values\n  // so I have to type it manually. @sacha_crispin\n  // Want to try?\n  // Uncomment AllOutputExtension in import in ../types/media.ts\n  outputFileType: // VIDEO\n  | \".mp4\"\n    | \".avi\"\n    | \".mov\"\n    | \".mkv\"\n    | \".mpg\"\n    | \".webm\"\n    // AUDIO\n    | \".mp3\"\n    | \".aac\"\n    | \".wav\"\n    | \".flac\"\n    | \".m4a\"\n    // IMAGE\n    | \".jpg\"\n    | \".png\"\n    | \".webp\"\n    | \".heic\"\n    | \".tiff\"\n    | \".avif\";\n  // Simple mode quality (optional). If omitted, sensible defaults apply.\n  quality?: QualityLevel;\n\n  // --- Optional advanced image controls (apply when relevant) ---\n  // Generic percentage for JPG/WEBP/HEIC/AVIF (0-100)\n  imageQualityPercent?: number;\n  // WEBP only: lossless mode (overrides imageQualityPercent)\n  webpLossless?: boolean;\n  // PNG only: \"png-24\" | \"png-8\"\n  pngVariant?: \"png-24\" | \"png-8\";\n  // TIFF only: \"deflate\" | \"lzw\"\n  tiffCompression?: \"deflate\" | \"lzw\";\n\n  // --- Optional advanced audio controls (apply when relevant) ---\n  audioBitrate?: \"64\" | \"96\" | \"128\" | \"160\" | \"192\" | \"224\" | \"256\" | \"320\";\n  audioVbr?: boolean;\n  audioProfile?: \"aac_low\" | \"aac_he\" | \"aac_he_v2\";\n  audioSampleRate?: \"22050\" | \"44100\" | \"48000\" | \"96000\";\n  audioBitDepth?: \"16\" | \"24\" | \"32\";\n  flacCompressionLevel?: \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\";\n\n  // --- Optional advanced video controls (apply when relevant) ---\n  videoEncodingMode?: \"crf\" | \"vbr\" | \"vbr-2-pass\";\n  videoCrf?: number; // 0-100 (mapped internally)\n  videoBitrate?:\n    | \"50000\"\n    | \"40000\"\n    | \"30000\"\n    | \"25000\"\n    | \"20000\"\n    | \"15000\"\n    | \"10000\"\n    | \"8000\"\n    | \"5000\"\n    | \"4000\"\n    | \"3000\"\n    | \"2000\"\n    | \"1500\"\n    | \"1000\"\n    | \"750\"\n    | \"500\";\n  videoMaxBitrate?:\n    | \"\"\n    | \"50000\"\n    | \"40000\"\n    | \"30000\"\n    | \"25000\"\n    | \"20000\"\n    | \"15000\"\n    | \"10000\"\n    | \"8000\"\n    | \"5000\"\n    | \"4000\"\n    | \"3000\"\n    | \"2000\"\n    | \"1500\"\n    | \"1000\"\n    | \"750\"\n    | \"500\";\n  videoPreset?: \"veryslow\" | \"slower\" | \"slow\" | \"medium\" | \"fast\" | \"faster\" | \"veryfast\" | \"superfast\" | \"ultrafast\";\n  // MOV only\n  proresVariant?: \"4444xq\" | \"4444\" | \"hq\" | \"standard\" | \"lt\" | \"proxy\";\n  // WEBM only\n  vp9Quality?: \"best\" | \"good\" | \"realtime\";\n};\n\nexport default async function ConvertMedia(input: Input) {\n  const {\n    inputPath,\n    outputFileType,\n    quality,\n    // image\n    imageQualityPercent,\n    webpLossless,\n    pngVariant,\n    tiffCompression,\n    // audio\n    audioBitrate,\n    audioVbr,\n    audioProfile,\n    audioSampleRate,\n    audioBitDepth,\n    flacCompressionLevel,\n    // video\n    videoEncodingMode,\n    videoCrf,\n    videoBitrate,\n    videoMaxBitrate,\n    videoPreset,\n    proresVariant,\n    vp9Quality,\n  } = input;\n  const installed = await findFFmpegPath();\n  if (!installed) {\n    return {\n      type: \"error\",\n      message: \"FFmpeg is not installed. Please install FFmpeg to use this tool.\",\n    };\n  }\n\n  let fullPath: string;\n  let mediaType: \"image\" | \"audio\" | \"video\" | null;\n\n  try {\n    fullPath = await getFullPath(inputPath);\n    mediaType = getMediaType(path.extname(fullPath));\n\n    if (!mediaType) {\n      return {\n        type: \"error\",\n        message: `Unsupported input file type for path: ${fullPath}`,\n      };\n    }\n  } catch (error) {\n    // Handle missing / invalid input path errors thrown by getFullPath\n    return {\n      type: \"error\",\n      message: String(error),\n    };\n  }\n\n  try {\n    let outputPath: string;\n    // Build quality settings with sensible defaults and advanced overrides\n    const buildQualitySettings = (): QualitySettings => {\n      // Default base settings for the chosen output file type\n      const baseDefault = DEFAULT_QUALITIES[outputFileType as keyof typeof DEFAULT_QUALITIES] as unknown;\n\n      if (mediaType === \"image\") {\n        // Image defaults are always the advanced type (percentages/variants)\n        const current = baseDefault as ImageQuality[OutputImageExtension];\n        let value: ImageQuality[OutputImageExtension] = current as ImageQuality[OutputImageExtension];\n\n        switch (outputFileType as OutputImageExtension) {\n          case \".jpg\": {\n            const pct = clampPercent(imageQualityPercent);\n            const next: ImageQuality[\".jpg\"] = (\n              typeof pct === \"number\" ? pct : (current as ImageQuality[\".jpg\"])\n            ) as ImageQuality[\".jpg\"];\n            value = next as unknown as ImageQuality[OutputImageExtension];\n            break;\n          }\n          case \".png\": {\n            const next: ImageQuality[\".png\"] = (\n              pngVariant && [\"png-24\", \"png-8\"].includes(pngVariant) ? pngVariant : (current as ImageQuality[\".png\"])\n            ) as ImageQuality[\".png\"];\n            value = next as unknown as ImageQuality[OutputImageExtension];\n            break;\n          }\n          case \".webp\": {\n            if (webpLossless) value = \"lossless\";\n            else {\n              const pct = clampPercent(imageQualityPercent);\n              const next: ImageQuality[\".webp\"] = (\n                typeof pct === \"number\" ? pct : (current as ImageQuality[\".webp\"])\n              ) as ImageQuality[\".webp\"];\n              value = next as unknown as ImageQuality[OutputImageExtension];\n            }\n            break;\n          }\n          case \".heic\": {\n            if (process.platform !== \"darwin\") {\n              throw new Error(\"HEIC output is only supported on macOS.\");\n            }\n            const pct = clampPercent(imageQualityPercent);\n            const next: ImageQuality[\".heic\"] = (\n              typeof pct === \"number\" ? pct : (current as ImageQuality[\".heic\"])\n            ) as ImageQuality[\".heic\"];\n            value = next as unknown as ImageQuality[OutputImageExtension];\n            break;\n          }\n          case \".tiff\": {\n            const next: ImageQuality[\".tiff\"] = (\n              tiffCompression && [\"deflate\", \"lzw\"].includes(tiffCompression)\n                ? tiffCompression\n                : (current as ImageQuality[\".tiff\"])\n            ) as ImageQuality[\".tiff\"];\n            value = next as unknown as ImageQuality[OutputImageExtension];\n            break;\n          }\n          case \".avif\": {\n            const pct = clampPercent(imageQualityPercent);\n            const next: ImageQuality[\".avif\"] = (\n              typeof pct === \"number\" ? pct : (current as ImageQuality[\".avif\"])\n            ) as ImageQuality[\".avif\"];\n            value = next as unknown as ImageQuality[OutputImageExtension];\n            break;\n          }\n        }\n\n        return { [outputFileType]: value } as QualitySettings;\n      }\n\n      if (mediaType === \"audio\") {\n        // If any advanced audio fields are provided, start from DEFAULT_QUALITIES and override.\n        const advancedProvided =\n          audioBitrate ||\n          typeof audioVbr === \"boolean\" ||\n          audioProfile ||\n          audioSampleRate ||\n          audioBitDepth ||\n          flacCompressionLevel;\n\n        let audioValue = (\n          advancedProvided\n            ? baseDefault\n            : quality\n              ? (SIMPLE_QUALITY_MAPPINGS[outputFileType as keyof typeof SIMPLE_QUALITY_MAPPINGS]?.[quality] ??\n                baseDefault)\n              : baseDefault\n        ) as AudioQuality[keyof AudioQuality];\n\n        switch (outputFileType as OutputAudioExtension) {\n          case \".mp3\": {\n            const current = audioValue as AudioQuality[\".mp3\"];\n            const next: AudioQuality[\".mp3\"] = {\n              bitrate: validateOneOf(audioBitrate, AUDIO_BITRATES, current.bitrate),\n              vbr: typeof audioVbr === \"boolean\" ? audioVbr : current.vbr,\n            };\n            audioValue = next;\n            break;\n          }\n          case \".aac\":\n          case \".m4a\": {\n            const current = audioValue as AudioQuality[\".aac\"];\n            const fallbackProfile: (typeof AUDIO_PROFILES)[number] = (current.profile ??\n              \"aac_low\") as (typeof AUDIO_PROFILES)[number];\n            const next: AudioQuality[\".aac\"] = {\n              bitrate: validateOneOf(audioBitrate, AUDIO_BITRATES, current.bitrate),\n              profile: validateOneOf(audioProfile, AUDIO_PROFILES, fallbackProfile),\n            };\n            audioValue = next;\n            break;\n          }\n          case \".wav\": {\n            const current = audioValue as AudioQuality[\".wav\"];\n            const next: AudioQuality[\".wav\"] = {\n              sampleRate: validateOneOf(audioSampleRate, AUDIO_SAMPLE_RATES, current.sampleRate),\n              bitDepth: validateOneOf(audioBitDepth, AUDIO_BIT_DEPTH, current.bitDepth),\n            };\n            audioValue = next;\n            break;\n          }\n          case \".flac\": {\n            const current = audioValue as AudioQuality[\".flac\"];\n            let bitDepth = validateOneOf(\n              (audioBitDepth ?? current.bitDepth) as \"16\" | \"24\",\n              [\"16\", \"24\"] as const,\n              current.bitDepth,\n            );\n            // Coerce 32 to 24 for FLAC if provided\n            if (audioBitDepth === \"32\") bitDepth = \"24\";\n            const next: AudioQuality[\".flac\"] = {\n              compressionLevel: validateOneOf(flacCompressionLevel, AUDIO_COMPRESSION_LEVEL, current.compressionLevel),\n              sampleRate: validateOneOf(audioSampleRate, AUDIO_SAMPLE_RATES, current.sampleRate),\n              bitDepth,\n            };\n            audioValue = next;\n            break;\n          }\n        }\n\n        return { [outputFileType]: audioValue } as QualitySettings;\n      }\n\n      if (mediaType === \"video\") {\n        const advancedProvided =\n          videoEncodingMode ||\n          typeof videoCrf === \"number\" ||\n          videoBitrate ||\n          typeof videoMaxBitrate === \"string\" ||\n          videoPreset ||\n          proresVariant ||\n          vp9Quality;\n\n        let videoValue = (\n          advancedProvided\n            ? baseDefault\n            : quality\n              ? (SIMPLE_QUALITY_MAPPINGS[outputFileType as keyof typeof SIMPLE_QUALITY_MAPPINGS]?.[quality] ??\n                baseDefault)\n              : baseDefault\n        ) as VideoQuality[keyof VideoQuality];\n\n        switch (outputFileType as OutputVideoExtension) {\n          case \".mov\": {\n            const current = videoValue as VideoQuality[\".mov\"];\n            const next: VideoQuality[\".mov\"] = {\n              variant: validateOneOf(proresVariant, PRORES_VARIANTS, current.variant),\n            };\n            videoValue = next;\n            break;\n          }\n          case \".webm\": {\n            const current = videoValue as VideoQuality[\".webm\"]; // has either crf or vbr variant + quality\n            const mode = validateOneOf(\n              videoEncodingMode,\n              VIDEO_ENCODING_MODES,\n              (current as Extract<VideoQuality[\".webm\"], { encodingMode: \"crf\" | \"vbr\" | \"vbr-2-pass\" }>)\n                .encodingMode ?? \"crf\",\n            );\n            if (mode === \"crf\") {\n              const currentCrf = (current as Extract<VideoQuality[\".webm\"], { encodingMode: \"crf\" }>).crf;\n              videoValue = {\n                encodingMode: \"crf\",\n                crf: clampPercent(videoCrf) ?? currentCrf,\n                quality: validateOneOf(\n                  vp9Quality,\n                  VP9_QUALITY,\n                  (current as Extract<VideoQuality[\".webm\"], { encodingMode: \"crf\" }>).quality ?? \"good\",\n                ),\n              } as VideoQuality[\".webm\"];\n            } else {\n              // Use sensible defaults instead of reading from current when switching modes\n              const defBitrate: (typeof VIDEO_BITRATE)[number] = \"2000\";\n              const defMax: (typeof VIDEO_MAX_BITRATE)[number] = \"\";\n              const defQuality: (typeof VP9_QUALITY)[number] = \"good\";\n              videoValue = {\n                encodingMode: mode,\n                bitrate: validateOneOf(videoBitrate, VIDEO_BITRATE, defBitrate),\n                maxBitrate: validateOneOf(videoMaxBitrate, VIDEO_MAX_BITRATE, defMax),\n                quality: validateOneOf(vp9Quality, VP9_QUALITY, defQuality),\n              } as VideoQuality[\".webm\"];\n            }\n            break;\n          }\n          case \".mp4\":\n          case \".mkv\": {\n            const current = videoValue as VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"] as\n              | VideoQuality[\".mp4\"]\n              | VideoQuality[\".mkv\"];\n            const mode = validateOneOf(\n              videoEncodingMode,\n              VIDEO_ENCODING_MODES,\n              (\n                current as Extract<\n                  VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"],\n                  { encodingMode: \"crf\" | \"vbr\" | \"vbr-2-pass\" }\n                >\n              ).encodingMode ?? \"crf\",\n            );\n            if (mode === \"crf\") {\n              const currentCrf = (current as Extract<VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"], { crf: number }>).crf;\n              const currentPreset =\n                (current as Extract<VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"], { preset?: unknown }>).preset ??\n                \"medium\";\n              videoValue = {\n                encodingMode: \"crf\",\n                crf: clampPercent(videoCrf) ?? currentCrf,\n                preset: validateOneOf(videoPreset, VIDEO_PRESET, currentPreset),\n              } as unknown as VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"];\n            } else {\n              const defBitrate: (typeof VIDEO_BITRATE)[number] = \"2000\";\n              const defMax: (typeof VIDEO_MAX_BITRATE)[number] = \"\";\n              const defPreset: (typeof VIDEO_PRESET)[number] = \"medium\";\n              videoValue = {\n                encodingMode: mode,\n                bitrate: validateOneOf(videoBitrate, VIDEO_BITRATE, defBitrate),\n                maxBitrate: validateOneOf(videoMaxBitrate, VIDEO_MAX_BITRATE, defMax),\n                preset: validateOneOf(videoPreset, VIDEO_PRESET, defPreset),\n              } as unknown as VideoQuality[\".mp4\"] | VideoQuality[\".mkv\"];\n            }\n            break;\n          }\n          case \".avi\":\n          case \".mpg\": {\n            const current = videoValue as VideoQuality[\".avi\"] | VideoQuality[\".mpg\"] as\n              | VideoQuality[\".avi\"]\n              | VideoQuality[\".mpg\"];\n            const mode = validateOneOf(\n              videoEncodingMode,\n              VIDEO_ENCODING_MODES,\n              (\n                current as Extract<\n                  VideoQuality[\".avi\"] | VideoQuality[\".mpg\"],\n                  { encodingMode: \"crf\" | \"vbr\" | \"vbr-2-pass\" }\n                >\n              ).encodingMode ?? \"crf\",\n            );\n            if (mode === \"crf\") {\n              const currentCrf = (current as Extract<VideoQuality[\".avi\"] | VideoQuality[\".mpg\"], { crf: number }>).crf;\n              videoValue = {\n                encodingMode: \"crf\",\n                crf: clampPercent(videoCrf) ?? currentCrf,\n              } as unknown as VideoQuality[\".avi\"] | VideoQuality[\".mpg\"];\n            } else {\n              const defBitrate: (typeof VIDEO_BITRATE)[number] = \"2000\";\n              const defMax: (typeof VIDEO_MAX_BITRATE)[number] = \"\";\n              videoValue = {\n                encodingMode: mode,\n                bitrate: validateOneOf(videoBitrate, VIDEO_BITRATE, defBitrate),\n                maxBitrate: validateOneOf(videoMaxBitrate, VIDEO_MAX_BITRATE, defMax),\n              } as unknown as VideoQuality[\".avi\"] | VideoQuality[\".mpg\"];\n            }\n            break;\n          }\n        }\n\n        return { [outputFileType]: videoValue } as QualitySettings;\n      }\n\n      // Fallback, should not reach\n      throw new Error(\"Unsupported media type for quality building\");\n    };\n\n    const qualitySettings = buildQualitySettings();\n\n    if (mediaType === \"image\") {\n      outputPath = await convertMedia(\n        fullPath,\n        outputFileType as OutputImageExtension,\n        qualitySettings as ImageQuality,\n      );\n    } else if (mediaType === \"audio\") {\n      outputPath = await convertMedia(\n        fullPath,\n        outputFileType as OutputAudioExtension,\n        qualitySettings as AudioQuality,\n      );\n    } else if (mediaType === \"video\") {\n      outputPath = await convertMedia(\n        fullPath,\n        outputFileType as OutputVideoExtension,\n        qualitySettings as VideoQuality,\n      );\n    } else {\n      return {\n        type: \"error\",\n        message: `Cannot convert ${mediaType} to ${outputFileType}. Invalid conversion pair.`,\n      };\n    }\n\n    const settingsSummary = summarizeSettings(mediaType, outputFileType, qualitySettings);\n    return {\n      type: \"success\",\n      message: `\u2705 Converted ${mediaType} to ${outputFileType}\\n- Input: ${fullPath}\\n- Output: ${outputPath}\\n- Settings: ${settingsSummary}`,\n    };\n  } catch (error) {\n    console.error(error);\n    return {\n      type: \"error\",\n      message: `\u274C The ${mediaType} could not be converted. Error: ${error}`,\n    };\n  }\n}\n\nexport const confirmation: Tool.Confirmation<Input> = async (params: Input) => {\n  try {\n    const fullPath = await getFullPath(params.inputPath);\n    const mediaType = getMediaType(path.extname(fullPath));\n    const message = \"This will create a new file in the same directory.\";\n    const info: { name: string; value: string }[] = [\n      { name: \"Input Path\", value: fullPath },\n      { name: \"Input Media Type\", value: mediaType || \"Unknown\" },\n      { name: \"Output File Type\", value: params.outputFileType },\n    ];\n\n    // Add simple quality if present\n    if (params.quality) info.push({ name: \"Quality (simple)\", value: String(params.quality) });\n\n    // Add advanced options summary if present\n    const advSummary = summarizeParams(params);\n    if (advSummary) info.push({ name: \"Advanced\", value: advSummary });\n\n    return {\n      message,\n      info,\n    };\n  } catch (error) {\n    // If the path is invalid or missing, surface a clear explanation instead of throwing\n    return {\n      message: String(error),\n      info: [],\n    };\n  }\n};\n\n// ------------------------- Helpers -------------------------\n\nfunction clampPercent(value: number | undefined): number | undefined {\n  if (typeof value !== \"number\" || Number.isNaN(value)) return undefined;\n  return Math.min(100, Math.max(0, Math.round(value)));\n}\n\nfunction validateOneOf<T extends readonly (string | number)[]>(\n  value: T[number] | undefined,\n  allowed: T,\n  fallback: T[number],\n): T[number] {\n  if (value !== undefined && (allowed as readonly (string | number)[]).includes(value as string | number)) {\n    return value as T[number];\n  }\n  return fallback;\n}\n\nfunction summarizeSettings(\n  mediaType: \"image\" | \"audio\" | \"video\",\n  outputFileType: Input[\"outputFileType\"],\n  qualitySettings: QualitySettings,\n): string {\n  if (mediaType === \"image\") {\n    const img = qualitySettings as Partial<ImageQuality>;\n    switch (outputFileType as OutputImageExtension) {\n      case \".jpg\":\n        return `quality ${img[\".jpg\"] as number}%`;\n      case \".heic\":\n        return `quality ${img[\".heic\"] as number}%`;\n      case \".avif\":\n        return `quality ${img[\".avif\"] as number}%`;\n      case \".webp\": {\n        const v = img[\".webp\"] as ImageQuality[\".webp\"];\n        return typeof v === \"string\" ? \"lossless\" : `quality ${v}%`;\n      }\n      case \".png\":\n        return `variant ${img[\".png\"] as ImageQuality[\".png\"]}`;\n      case \".tiff\":\n        return `compression ${img[\".tiff\"] as ImageQuality[\".tiff\"]}`;\n    }\n  }\n  if (mediaType === \"audio\") {\n    const aud = qualitySettings as Partial<AudioQuality>;\n    switch (outputFileType as OutputAudioExtension) {\n      case \".mp3\": {\n        const v = aud[\".mp3\"] as AudioQuality[\".mp3\"];\n        return `bitrate ${v.bitrate} kbps${v.vbr ? \", VBR\" : \"\"}`;\n      }\n      case \".aac\": {\n        const v = aud[\".aac\"] as AudioQuality[\".aac\"];\n        return `bitrate ${v.bitrate} kbps${v.profile ? `, profile ${v.profile}` : \"\"}`;\n      }\n      case \".m4a\": {\n        const v = aud[\".m4a\"] as AudioQuality[\".m4a\"];\n        return `bitrate ${v.bitrate} kbps${v.profile ? `, profile ${v.profile}` : \"\"}`;\n      }\n      case \".wav\": {\n        const v = aud[\".wav\"] as AudioQuality[\".wav\"];\n        return `${v.sampleRate} Hz, ${v.bitDepth}-bit`;\n      }\n      case \".flac\": {\n        const v = aud[\".flac\"] as AudioQuality[\".flac\"];\n        return `level ${v.compressionLevel}, ${v.sampleRate} Hz, ${v.bitDepth}-bit`;\n      }\n    }\n  }\n  if (mediaType === \"video\") {\n    const vid = qualitySettings as Partial<VideoQuality>;\n    switch (outputFileType as OutputVideoExtension) {\n      case \".mov\": {\n        const v = vid[\".mov\"] as VideoQuality[\".mov\"];\n        return `ProRes ${v.variant}`;\n      }\n      case \".webm\": {\n        const v = vid[\".webm\"] as VideoQuality[\".webm\"];\n        if (v.encodingMode === \"crf\") {\n          return `CRF ${v.crf}, VP9 ${v.quality}`;\n        }\n        return `${v.encodingMode.toUpperCase()} ${v.bitrate} kbps${v.maxBitrate ? ` max ${v.maxBitrate}` : \"\"}, VP9 ${v.quality}`;\n      }\n      case \".mp4\": {\n        const v = vid[\".mp4\"] as VideoQuality[\".mp4\"];\n        if (v.encodingMode === \"crf\") {\n          return `CRF ${v.crf}, preset ${v.preset}`;\n        }\n        return `${v.encodingMode.toUpperCase()} ${v.bitrate} kbps${v.maxBitrate ? ` max ${v.maxBitrate}` : \"\"}, preset ${v.preset}`;\n      }\n      case \".mkv\": {\n        const v = vid[\".mkv\"] as VideoQuality[\".mkv\"];\n        if (v.encodingMode === \"crf\") {\n          return `CRF ${v.crf}, preset ${v.preset}`;\n        }\n        return `${v.encodingMode.toUpperCase()} ${v.bitrate} kbps${v.maxBitrate ? ` max ${v.maxBitrate}` : \"\"}, preset ${v.preset}`;\n      }\n      case \".avi\": {\n        const v = vid[\".avi\"] as VideoQuality[\".avi\"];\n        if (v.encodingMode === \"crf\") {\n          return `CRF ${v.crf}`;\n        }\n        return `${v.encodingMode.toUpperCase()} ${v.bitrate} kbps${v.maxBitrate ? ` max ${v.maxBitrate}` : \"\"}`;\n      }\n      case \".mpg\": {\n        const v = vid[\".mpg\"] as VideoQuality[\".mpg\"];\n        if (v.encodingMode === \"crf\") {\n          return `CRF ${v.crf}`;\n        }\n        return `${v.encodingMode.toUpperCase()} ${v.bitrate} kbps${v.maxBitrate ? ` max ${v.maxBitrate}` : \"\"}`;\n      }\n    }\n  }\n  return \"default\";\n}\n\nfunction summarizeParams(params: Input): string {\n  const parts: string[] = [];\n  // image\n  if (typeof params.imageQualityPercent === \"number\") parts.push(`imageQuality ${params.imageQualityPercent}%`);\n  if (params.webpLossless) parts.push(`webp lossless`);\n  if (params.pngVariant) parts.push(`png ${params.pngVariant}`);\n  if (params.tiffCompression) parts.push(`tiff ${params.tiffCompression}`);\n  // audio\n  if (params.audioBitrate) parts.push(`audio bitrate ${params.audioBitrate}`);\n  if (typeof params.audioVbr === \"boolean\") parts.push(`audio vbr ${params.audioVbr ? \"on\" : \"off\"}`);\n  if (params.audioProfile) parts.push(`audio profile ${params.audioProfile}`);\n  if (params.audioSampleRate) parts.push(`audio sample ${params.audioSampleRate}`);\n  if (params.audioBitDepth) parts.push(`audio bitDepth ${params.audioBitDepth}`);\n  if (params.flacCompressionLevel) parts.push(`flac level ${params.flacCompressionLevel}`);\n  // video\n  if (params.videoEncodingMode) parts.push(`video mode ${params.videoEncodingMode}`);\n  if (typeof params.videoCrf === \"number\") parts.push(`video crf ${params.videoCrf}`);\n  if (params.videoBitrate) parts.push(`video bitrate ${params.videoBitrate}`);\n  if (typeof params.videoMaxBitrate === \"string\") parts.push(`video maxBitrate ${params.videoMaxBitrate || \"none\"}`);\n  if (params.videoPreset) parts.push(`video preset ${params.videoPreset}`);\n  if (params.proresVariant) parts.push(`prores ${params.proresVariant}`);\n  if (params.vp9Quality) parts.push(`vp9 ${params.vp9Quality}`);\n  return parts.join(\", \");\n}\n", "import path from \"path\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { findFFmpegPath } from \"./ffmpeg\";\nimport { execPromise } from \"./exec\";\nimport {\n  AllOutputExtension,\n  OutputImageExtension,\n  OutputAudioExtension,\n  OutputVideoExtension,\n  QualitySettings,\n  ImageQuality,\n  AudioQuality,\n  VideoQuality,\n  getMediaType,\n  Percentage,\n} from \"../types/media\";\n\nfunction convertQualityToCrf(qualityPercentage: Percentage): number {\n  // Map 100% quality to CRF 0, and 0% quality to CRF 51\n  // Using a linear mapping for simplicity\n  return Math.round(51 - (qualityPercentage / 100) * 51);\n}\n\nexport function getUniqueOutputPath(filePath: string, extension: string): string {\n  const outputFilePath = filePath.replace(path.extname(filePath), extension);\n  let finalOutputPath = outputFilePath;\n  let counter = 1;\n\n  while (fs.existsSync(finalOutputPath)) {\n    const fileName = path.basename(outputFilePath, extension);\n    const dirName = path.dirname(outputFilePath);\n    finalOutputPath = path.join(dirName, `${fileName}(${counter})${extension}`);\n    counter++;\n  }\n\n  return finalOutputPath;\n}\n\nexport async function convertMedia<T extends AllOutputExtension>(\n  filePath: string,\n  outputFormat: T,\n  quality: QualitySettings,\n): Promise<string> {\n  const ffmpegPath = await findFFmpegPath();\n\n  // In theory, this should never happen\n  if (!ffmpegPath) {\n    throw new Error(\"FFmpeg is not installed or configured. Please install FFmpeg to use this converter.\");\n  }\n\n  let ffmpegCmd = `\"${ffmpegPath.path}\" -i`;\n  const currentMediaType = getMediaType(path.extname(filePath))!;\n  switch (currentMediaType) {\n    case \"image\": {\n      const currentOutputFormat = outputFormat as OutputImageExtension;\n      const imageQuality = quality as ImageQuality;\n      const finalOutputPath = getUniqueOutputPath(filePath, currentOutputFormat);\n\n      let tempHeicFile: string | null = null;\n      let tempPaletteFile: string | null = null;\n      const extension = path.extname(filePath).toLowerCase();\n      let processedInputPath = filePath;\n\n      try {\n        // HEIC conversion is theoretically only available on macOS via the built-in SIPS utility.\n        if (currentOutputFormat === \".heic\") {\n          try {\n            // Attempt HEIC conversion using SIPS directly\n            await execPromise(\n              `sips --setProperty format heic --setProperty formatOptions ${imageQuality[\".heic\"]} \"${filePath}\" --out \"${finalOutputPath}\"`,\n            );\n          } catch (error) {\n            // Parse error to provide more specific feedback\n            const errorMessage = String(error);\n\n            if (errorMessage.includes(\"command not found\") || errorMessage.includes(\"not recognized\")) {\n              throw new Error(\n                \"HEIC conversion failed: 'sips' command not found. \" +\n                  \"Converting to HEIC format is theoretically only available on macOS, \" +\n                  \"as it requires the built-in SIPS utility with proper HEIC support \" +\n                  \"(libheif, libde265, and x265 dependencies).\",\n              );\n            } else {\n              throw new Error(\n                \"HEIC conversion failed: SIPS command found but conversion unsuccessful. \" +\n                  \"This may indicate that your SIPS installation lacks proper HEIC support. \" +\n                  \"Converting to HEIC format typically requires macOS with built-in SIPS that includes \" +\n                  \"libheif, libde265, and x265 dependencies. Error details: \" +\n                  String(error),\n              );\n            }\n          }\n        } else {\n          // If the input file is HEIC and the output format is not HEIC, convert to PNG first\n          if (extension === \".heic\") {\n            try {\n              const tempFileName = `${path.basename(filePath, \".heic\")}_temp_${Date.now()}.png`;\n              tempHeicFile = path.join(os.tmpdir(), tempFileName);\n\n              await execPromise(`sips --setProperty format png \"${filePath}\" --out \"${tempHeicFile}\"`);\n\n              processedInputPath = tempHeicFile;\n            } catch (error) {\n              console.error(`Error pre-processing HEIC file: ${filePath}`, error);\n              if (tempHeicFile && fs.existsSync(tempHeicFile)) {\n                fs.unlinkSync(tempHeicFile);\n              }\n              throw new Error(`Failed to preprocess HEIC file: ${String(error)}`);\n            }\n          }\n\n          ffmpegCmd += ` \"${processedInputPath}\"`;\n\n          switch (currentOutputFormat) {\n            case \".jpg\":\n              // mjpeg takes in 2 (best) to 31 (worst)\n              ffmpegCmd += ` -q:v ${Math.round(31 - (imageQuality[\".jpg\"] / 100) * 29)}`;\n              break;\n            case \".png\":\n              if (imageQuality[\".png\"] === \"png-8\") {\n                const tempPaletteFileName = `${path.basename(filePath, path.extname(filePath))}_palette_${Date.now()}.png`;\n                tempPaletteFile = path.join(os.tmpdir(), tempPaletteFileName);\n\n                // Generate palette first\n                await execPromise(\n                  `\"${ffmpegPath.path}\" -i \"${processedInputPath}\" -vf \"palettegen=max_colors=256\" -y \"${tempPaletteFile}\"`,\n                );\n                // Then apply palette\n                ffmpegCmd = `\"${ffmpegPath.path}\" -i \"${processedInputPath}\" -i \"${tempPaletteFile}\" -lavfi \"paletteuse=dither=bayer:bayer_scale=5\"`;\n              }\n              ffmpegCmd += ` -compression_level 100 \"${finalOutputPath}\"`;\n              break;\n            case \".webp\":\n              ffmpegCmd += \" -c:v libwebp\";\n              if (imageQuality[\".webp\"] === \"lossless\") {\n                ffmpegCmd += \" -lossless 1\";\n              } else {\n                ffmpegCmd += ` -quality ${imageQuality[\".webp\"]}`;\n              }\n              break;\n            case \".tiff\":\n              ffmpegCmd += ` -compression_algo ${imageQuality[\".tiff\"]}`;\n              break;\n            case \".avif\":\n              // libaom-av1 takes in 0 (best/lossless) to 63 (worst)\n              ffmpegCmd += ` -c:v libaom-av1 -crf ${Math.round(63 - (Number(imageQuality[\".avif\"]) / 100) * 63)} -still-picture 1`;\n              break;\n          }\n          if (currentOutputFormat !== \".png\" || imageQuality[\".png\"] !== \"png-8\") {\n            ffmpegCmd += ` -y \"${finalOutputPath}\"`;\n          }\n          console.log(`Executing FFmpeg image command: ${ffmpegCmd}`);\n          await execPromise(ffmpegCmd);\n        }\n        return finalOutputPath;\n      } catch (error) {\n        console.error(`Error converting ${processedInputPath} to ${currentOutputFormat}:`, error);\n        throw error;\n      } finally {\n        // Clean up temp files if they exist\n        if (tempHeicFile && fs.existsSync(tempHeicFile)) {\n          fs.unlinkSync(tempHeicFile);\n        }\n        if (tempPaletteFile && fs.existsSync(tempPaletteFile)) {\n          fs.unlinkSync(tempPaletteFile);\n        }\n      }\n    }\n\n    case \"audio\": {\n      const currentOutputFormat = outputFormat as OutputAudioExtension;\n      const audioQuality = quality as AudioQuality;\n      const finalOutputPath = getUniqueOutputPath(filePath, currentOutputFormat);\n\n      ffmpegCmd += ` \"${filePath}\"`;\n\n      switch (currentOutputFormat) {\n        case \".mp3\": {\n          const mp3Settings = audioQuality[\".mp3\"];\n          ffmpegCmd += ` -c:a libmp3lame`;\n          if (mp3Settings.vbr) {\n            ffmpegCmd += ` -q:a ${Math.round((320 - Number(mp3Settings.bitrate)) / 40)}`; // Convert bitrate to VBR quality\n          } else {\n            ffmpegCmd += ` -b:a ${mp3Settings.bitrate}k`;\n          }\n          break;\n        }\n        case \".aac\": {\n          const aacSettings = audioQuality[\".aac\"];\n          ffmpegCmd += ` -c:a aac -b:a ${aacSettings.bitrate}k`;\n          if (aacSettings.profile) {\n            ffmpegCmd += ` -profile:a ${aacSettings.profile}`;\n          }\n          break;\n        }\n        case \".m4a\": {\n          const m4aSettings = audioQuality[\".m4a\"];\n          ffmpegCmd += ` -c:a aac -b:a ${m4aSettings.bitrate}k`;\n          if (m4aSettings.profile) {\n            ffmpegCmd += ` -profile:a ${m4aSettings.profile}`;\n          }\n          break;\n        }\n        case \".wav\": {\n          const wavSettings = audioQuality[\".wav\"];\n          ffmpegCmd += ` -c:a pcm_s${wavSettings.bitDepth}le -ar ${wavSettings.sampleRate}`;\n          break;\n        }\n        case \".flac\": {\n          const flacSettings = audioQuality[\".flac\"];\n          ffmpegCmd += ` -c:a flac -compression_level ${flacSettings.compressionLevel} -ar ${flacSettings.sampleRate}`;\n          if (flacSettings.bitDepth === \"24\") {\n            ffmpegCmd += ` -sample_fmt s32`;\n          }\n          break;\n        }\n        default:\n          throw new Error(`Unknown audio output format: ${currentOutputFormat}`);\n      }\n\n      ffmpegCmd += ` -y \"${finalOutputPath}\"`;\n      console.log(`Executing FFmpeg audio command: ${ffmpegCmd}`);\n      await execPromise(ffmpegCmd);\n      return finalOutputPath;\n    }\n\n    case \"video\": {\n      const currentOutputFormat = outputFormat as OutputVideoExtension;\n      const videoQuality = quality as VideoQuality;\n\n      ffmpegCmd += ` \"${filePath}\"`;\n\n      // Add format-specific codec and settings\n      switch (currentOutputFormat) {\n        case \".mp4\": {\n          const mp4Quality = videoQuality[\".mp4\"];\n          ffmpegCmd += ` -vcodec h264 -acodec aac -preset ${mp4Quality.preset}`;\n          break;\n        }\n        case \".avi\": {\n          ffmpegCmd += ` -vcodec libxvid -acodec mp3`;\n          break;\n        }\n        case \".mov\": {\n          const movQuality = videoQuality[\".mov\"];\n          const proresProfiles = {\n            proxy: \"0\",\n            lt: \"1\",\n            standard: \"2\",\n            hq: \"3\",\n            \"4444\": \"4\",\n            \"4444xq\": \"5\",\n          };\n          ffmpegCmd += ` -vcodec prores -profile:v ${proresProfiles[movQuality.variant]} -acodec pcm_s16le`;\n          break;\n        }\n        case \".mkv\": {\n          const mkvQuality = videoQuality[\".mkv\"];\n          ffmpegCmd += ` -vcodec libx265 -acodec aac -preset ${mkvQuality.preset}`;\n          break;\n        }\n        case \".mpg\": {\n          ffmpegCmd += ` -vcodec mpeg2video -acodec mp3`;\n          break;\n        }\n        case \".webm\": {\n          const webmQuality = videoQuality[\".webm\"];\n          ffmpegCmd += ` -vcodec libvpx-vp9 -acodec libopus -quality ${webmQuality.quality}`;\n          break;\n        }\n        default:\n          throw new Error(`Unknown video output format: ${currentOutputFormat}`);\n      }\n\n      // Handle encoding mode (unified for all formats except .mov)\n      const finalOutputPath = getUniqueOutputPath(filePath, currentOutputFormat);\n      let logFilePrefix: string | null = null;\n\n      if (currentOutputFormat !== \".mov\") {\n        const qualitySettings = videoQuality[currentOutputFormat];\n\n        if (\"encodingMode\" in qualitySettings) {\n          if (qualitySettings.encodingMode === \"crf\") {\n            ffmpegCmd += ` -crf ${convertQualityToCrf(qualitySettings.crf)}`;\n          } else {\n            // VBR or VBR 2-pass\n            ffmpegCmd += ` -b:v ${qualitySettings.bitrate}k`;\n\n            if (\"maxBitrate\" in qualitySettings && qualitySettings.maxBitrate) {\n              ffmpegCmd += ` -maxrate ${qualitySettings.maxBitrate}k -bufsize ${Number(qualitySettings.maxBitrate) * 2}k`;\n            }\n\n            if (qualitySettings.encodingMode === \"vbr-2-pass\") {\n              // First pass - need to specify log file prefix for 2-pass encoding\n              logFilePrefix = path.join(os.tmpdir(), `ffmpeg2pass_${Date.now()}`);\n              const nullDevice = process.platform === \"win32\" ? \"NUL\" : \"/dev/null\";\n              const firstPassCmd = ffmpegCmd + ` -pass 1 -passlogfile \"${logFilePrefix}\" -f null ${nullDevice}`;\n              try {\n                await execPromise(firstPassCmd);\n              } catch (error) {\n                throw new Error(`First pass encoding failed: ${error}`);\n              }\n              // Second pass will be executed below\n              ffmpegCmd += ` -pass 2 -passlogfile \"${logFilePrefix}\"`;\n            }\n          }\n        }\n      }\n\n      try {\n        ffmpegCmd += ` -y \"${finalOutputPath}\"`;\n        console.log(`Executing FFmpeg video command: ${ffmpegCmd}`);\n        await execPromise(ffmpegCmd);\n        return finalOutputPath;\n      } finally {\n        // Clean up 2-pass log files if they exist\n        if (logFilePrefix) {\n          try {\n            // Clean up all possible FFmpeg 2-pass log files\n            const logFiles = [\n              `${logFilePrefix}-0.log`,\n              `${logFilePrefix}-0.log.mbtree`,\n              `${logFilePrefix}-0.log.temp`,\n              `${logFilePrefix}-1.log`,\n              `${logFilePrefix}-1.log.mbtree`,\n              `${logFilePrefix}-1.log.temp`,\n            ];\n\n            for (const logFile of logFiles) {\n              if (fs.existsSync(logFile)) {\n                try {\n                  fs.unlinkSync(logFile);\n                } catch (fileError) {\n                  console.warn(`Failed to clean up log file ${logFile}:`, fileError);\n                }\n              }\n            }\n          } catch (error) {\n            console.warn(\"Failed to clean up FFmpeg log files:\", error);\n          }\n        }\n      }\n    }\n\n    default:\n      throw new Error(`Unsupported media type for file: ${filePath}`);\n  }\n}\n", "import fs from \"fs\";\nimport os from \"os\";\nimport { LocalStorage, environment, getPreferenceValues } from \"@raycast/api\";\nimport { execPromise } from \"./exec\";\nimport * as ffmpegStatic from \"./ffmpeg-static\";\n\nexport async function checkFFmpegVersion(ffmpegPath: string): Promise<number | null> {\n  try {\n    const { stdout } = await execPromise(`\"${ffmpegPath}\" -version`);\n    const versionMatch = stdout.match(/ffmpeg version (\\d+)\\.(\\d+)/);\n    if (versionMatch) {\n      const major = parseInt(versionMatch[1], 10);\n      const minor = parseInt(versionMatch[2], 10);\n      return major + minor / 10; // Convert to decimal format like 6.1\n    }\n    return null;\n  } catch (error) {\n    console.error(\"Error checking FFmpeg version:\", error);\n    return null;\n  }\n}\n\nexport async function findFFmpegPath(minimumVersion = 6.0): Promise<{ path: string; version: number } | null> {\n  try {\n    // First, check if there's a custom path in preferences\n    const preferences = getPreferenceValues();\n    const customPath = preferences.ffmpeg_path;\n\n    if (customPath && customPath.trim() && fs.existsSync(customPath)) {\n      const version = await checkFFmpegVersion(customPath);\n      if (version && version >= minimumVersion) {\n        // Store the valid custom path\n        await LocalStorage.setItem(\"ffmpeg-path\", customPath);\n        console.log(`Found custom FFmpeg at: ${customPath} with version: ${version}`);\n        return { path: customPath, version };\n      }\n    }\n\n    // Check stored ffmpeg path (from previous auto-detection or installation)\n    const storedPath = await LocalStorage.getItem(\"ffmpeg-path\");\n    if (storedPath && typeof storedPath === \"string\" && fs.existsSync(storedPath)) {\n      const version = await checkFFmpegVersion(storedPath);\n      if (version && version >= minimumVersion) {\n        return { path: storedPath, version };\n      }\n    }\n\n    // Check common system installation paths directly\n    const platform = os.platform();\n    const commonPaths = [];\n\n    // On MacOS, the which command is not included in the minimal shell environment that Node.js has access to,\n    // so this feature is on hold for now.\n    /* try {\n      const command = platform === \"win32\" ? \"where ffmpeg\" : \"which ffmpeg\";\n      console.log(`Executing command: ${command}`);\n\n      const { stdout } = await execPromise(command);\n      console.log(`Command output (raw): \"${stdout}\"`);\n      console.log(`Command output (trimmed): \"${stdout.trim()}\"`);\n\n      const systemPath = stdout.trim().split(\"\\n\")[0];\n      console.log(`Found ffmpeg in system PATH: ${systemPath}`);\n\n      if (systemPath && fs.existsSync(systemPath)) {\n        console.log(`Path exists, adding to commonPaths: ${systemPath}`);\n        commonPaths.push(systemPath);\n      } else {\n        console.log(\n          `Path validation failed - systemPath: \"${systemPath}\", exists: ${systemPath ? fs.existsSync(systemPath) : false}`,\n        );\n      }\n    } catch (error) {\n      console.log(`Command failed with error:`, error);\n    } */\n\n    // Note: the following common paths were generated by Claude Sonnet 4, I did not verify them all, but they are likely to be correct.\n    // Even if they aren't, the user will be able to specify their custom path in the extension preferences.\n    if (platform === \"darwin\") {\n      // macOS common paths\n      commonPaths.push(\n        // Homebrew (Intel)\n        \"/usr/local/bin/ffmpeg\",\n        // Homebrew (Apple Silicon)\n        \"/opt/homebrew/bin/ffmpeg\",\n        // System paths\n        \"/usr/bin/ffmpeg\",\n        // MacPorts\n        \"/opt/local/bin/ffmpeg\",\n        // Nix\n        \"/nix/store/*/bin/ffmpeg\",\n        `${os.homedir()}/.nix-profile/bin/ffmpeg`,\n        \"/run/current-system/sw/bin/ffmpeg\",\n        // Conda/Miniconda/Anaconda\n        `${os.homedir()}/miniconda3/bin/ffmpeg`,\n        `${os.homedir()}/anaconda3/bin/ffmpeg`,\n        `${os.homedir()}/mambaforge/bin/ffmpeg`,\n        \"/usr/local/miniconda3/bin/ffmpeg\",\n        \"/usr/local/anaconda3/bin/ffmpeg\",\n        // Fink\n        \"/sw/bin/ffmpeg\",\n        // Manual installations\n        \"/Applications/ffmpeg\",\n        \"/Applications/FFmpeg/ffmpeg\",\n        `${os.homedir()}/bin/ffmpeg`,\n        `${os.homedir()}/.local/bin/ffmpeg`,\n        // pkgsrc\n        \"/usr/pkg/bin/ffmpeg\",\n      );\n    } else if (platform === \"win32\") {\n      // Windows common paths\n      const programFiles = process.env.ProgramFiles || \"C:\\\\Program Files\";\n      const programFilesX86 = process.env[\"ProgramFiles(x86)\"] || \"C:\\\\Program Files (x86)\";\n      const userProfile = process.env.USERPROFILE || \"C:\\\\Users\\\\%USERNAME%\";\n      const localAppData = process.env.LOCALAPPDATA || `${userProfile}\\\\AppData\\\\Local`;\n\n      commonPaths.push(\n        // Standard installation paths\n        `${programFiles}\\\\ffmpeg\\\\bin\\\\ffmpeg.exe`,\n        `${programFilesX86}\\\\ffmpeg\\\\bin\\\\ffmpeg.exe`,\n        \"C:\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\",\n        // Chocolatey\n        `${programFiles}\\\\ffmpeg\\\\ffmpeg.exe`,\n        \"C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\ffmpeg\\\\tools\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\",\n        \"C:\\\\tools\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\",\n        // Scoop\n        `${userProfile}\\\\scoop\\\\apps\\\\ffmpeg\\\\current\\\\bin\\\\ffmpeg.exe`,\n        `${userProfile}\\\\scoop\\\\shims\\\\ffmpeg.exe`,\n        // winget\n        `${localAppData}\\\\Microsoft\\\\WinGet\\\\Packages\\\\Gyan.FFmpeg_Microsoft.Winget.Source_*\\\\ffmpeg-*\\\\bin\\\\ffmpeg.exe`,\n        // Conda/Miniconda/Anaconda\n        `${userProfile}\\\\miniconda3\\\\Scripts\\\\ffmpeg.exe`,\n        `${userProfile}\\\\anaconda3\\\\Scripts\\\\ffmpeg.exe`,\n        `${userProfile}\\\\mambaforge\\\\Scripts\\\\ffmpeg.exe`,\n        \"C:\\\\ProgramData\\\\Miniconda3\\\\Scripts\\\\ffmpeg.exe\",\n        \"C:\\\\ProgramData\\\\Anaconda3\\\\Scripts\\\\ffmpeg.exe\",\n        // MSYS2/MinGW\n        \"C:\\\\msys64\\\\usr\\\\bin\\\\ffmpeg.exe\",\n        \"C:\\\\msys64\\\\mingw64\\\\bin\\\\ffmpeg.exe\",\n        \"C:\\\\msys64\\\\mingw32\\\\bin\\\\ffmpeg.exe\",\n        // User local installations\n        `${userProfile}\\\\bin\\\\ffmpeg.exe`,\n        `${userProfile}\\\\Tools\\\\ffmpeg\\\\bin\\\\ffmpeg.exe`,\n        `${localAppData}\\\\Programs\\\\ffmpeg\\\\bin\\\\ffmpeg.exe`,\n      );\n    } else {\n      // Linux & Unix common paths\n      const homeDir = os.homedir();\n\n      commonPaths.push(\n        // System paths\n        \"/usr/bin/ffmpeg\",\n        \"/usr/local/bin/ffmpeg\",\n        \"/bin/ffmpeg\",\n        // Snap\n        \"/snap/bin/ffmpeg\",\n        \"/var/lib/snapd/snap/bin/ffmpeg\",\n        // Flatpak\n        \"/var/lib/flatpak/exports/bin/org.ffmpeg.FFmpeg\",\n        `${homeDir}/.local/share/flatpak/exports/bin/org.ffmpeg.FFmpeg`,\n        // AppImage\n        `${homeDir}/Applications/ffmpeg.AppImage`,\n        `${homeDir}/.local/bin/ffmpeg.AppImage`,\n        // Nix\n        \"/nix/store/*/bin/ffmpeg\",\n        `${homeDir}/.nix-profile/bin/ffmpeg`,\n        \"/run/current-system/sw/bin/ffmpeg\",\n        // Conda/Miniconda/Anaconda\n        `${homeDir}/miniconda3/bin/ffmpeg`,\n        `${homeDir}/anaconda3/bin/ffmpeg`,\n        `${homeDir}/mambaforge/bin/ffmpeg`,\n        \"/opt/miniconda3/bin/ffmpeg\",\n        \"/opt/anaconda3/bin/ffmpeg\",\n        // User local installations\n        `${homeDir}/bin/ffmpeg`,\n        `${homeDir}/.local/bin/ffmpeg`,\n        // Distribution-specific paths\n        \"/opt/ffmpeg/bin/ffmpeg\",\n        \"/usr/local/ffmpeg/bin/ffmpeg\",\n        // Build from source common locations\n        `${homeDir}/ffmpeg/ffmpeg`,\n        `${homeDir}/src/ffmpeg/ffmpeg`,\n        \"/opt/local/bin/ffmpeg\", // MacPorts on some Linux distros\n      );\n    }\n\n    // Check if any of the common paths exist and meet version requirements\n    for (const path of commonPaths) {\n      if (fs.existsSync(path)) {\n        const version = await checkFFmpegVersion(path);\n        if (version && version >= minimumVersion) {\n          // Store the found path for future use\n          await LocalStorage.setItem(\"ffmpeg-path\", path);\n          console.log(`Found FFmpeg at: ${path} with version: ${version}`);\n          return { path, version };\n        }\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.error(\"Error finding valid FFmpeg:\", error);\n    return null;\n  }\n}\n\nexport async function installFFmpegBinary(onProgress?: (progress: number) => void): Promise<void> {\n  try {\n    const downloadDir = environment.supportPath;\n\n    // Ensure the download directory exists\n    if (!fs.existsSync(downloadDir)) {\n      fs.mkdirSync(downloadDir, { recursive: true });\n    }\n\n    console.log(`Download dir set to: ${downloadDir}`);\n\n    // Get the expected binary path for the custom download directory\n    const ffmpegPath = ffmpegStatic.getBinaryPath(downloadDir);\n\n    console.log(`FFmpeg static returned path: ${ffmpegPath}`);\n\n    if (!ffmpegPath) {\n      throw new Error(\"FFmpeg installer did not provide a valid path for this platform\");\n    }\n\n    // Check if the binary already exists at the returned path (if weird user behavior during download)\n    let needsInstallation = !fs.existsSync(ffmpegPath);\n\n    // If binary exists, verify it's working properly\n    if (!needsInstallation) {\n      try {\n        console.log(\"FFmpeg binary exists, verifying it works...\");\n        const { stdout } = await execPromise(`\"${ffmpegPath}\" -version`);\n        if (!stdout.includes(\"ffmpeg version\")) {\n          console.log(\"Existing FFmpeg binary is not working properly, will reinstall\");\n          needsInstallation = true;\n        } else {\n          console.log(\"Existing FFmpeg binary is working properly\");\n        }\n      } catch (error) {\n        console.log(\"Existing FFmpeg binary verification failed, will reinstall:\", error);\n        needsInstallation = true;\n      }\n    }\n\n    if (needsInstallation) {\n      // If binary exists but is corrupted, remove it first\n      if (fs.existsSync(ffmpegPath)) {\n        console.log(\"Removing corrupted FFmpeg binary...\");\n        try {\n          fs.unlinkSync(ffmpegPath);\n        } catch (error) {\n          console.warn(\"Warning: Could not remove corrupted binary:\", error);\n          // Continue anyway, the installer might overwrite it\n        }\n      }\n\n      console.log(\"FFmpeg binary not found or corrupted, running install process...\");\n      await ffmpegStatic.installBinary(downloadDir, onProgress);\n    }\n\n    // Check again after potential install\n    if (!fs.existsSync(ffmpegPath)) {\n      throw new Error(`FFmpeg binary not found at expected path: ${ffmpegPath}`);\n    }\n\n    // Make it executable (Unix/Linux/macOS only, on Windows .exe files are executable by default)\n    const platform = os.platform();\n    if (platform !== \"win32\") {\n      try {\n        fs.chmodSync(ffmpegPath, 0o755);\n      } catch (error) {\n        console.warn(\"Warning: Could not set executable permissions:\", error);\n        // Continue execution as this might not be critical on some systems\n      }\n    }\n\n    // Final verification that the binary works (only if we just installed it)\n    if (needsInstallation) {\n      const { stdout } = await execPromise(`\"${ffmpegPath}\" -version`);\n      if (!stdout.includes(\"ffmpeg version\")) {\n        throw new Error(\"FFmpeg binary installation verification failed\");\n      }\n    }\n\n    // Store the path\n    await LocalStorage.setItem(\"ffmpeg-path\", ffmpegPath);\n    console.log(`FFmpeg successfully installed to: ${ffmpegPath}`);\n  } catch (error) {\n    console.error(\"Error installing FFmpeg:\", error);\n    throw error;\n  }\n}\n", "import util from \"util\";\nimport { exec } from \"child_process\";\n\nexport const execPromise = util.promisify(exec);\n", "import { type PreferenceValues } from \"@raycast/api\";\n\ntype Range<\n  START extends number,\n  END extends number,\n  ARR extends unknown[] = [],\n  ACC extends number = never,\n> = ARR[\"length\"] extends END\n  ? ACC | END\n  : Range<START, END, [...ARR, 1], ARR[\"length\"] extends START ? ARR[\"length\"] : ACC | ARR[\"length\"]>;\n\n// =============================================================================\n// Media Converter Type Declarations\n// =============================================================================\n\n// Simple range type for percentages (0-100)\nexport type Percentage = Range<0, 100>;\n\n// Quality level presets (user-friendly)\nexport type QualityLevel = \"lowest\" | \"low\" | \"medium\" | \"high\" | \"highest\";\n\n// Simple quality settings type for basic mode\nexport type SimpleQualitySettings = {\n  [K in AllOutputExtension]: QualityLevel;\n};\n\n// Basic format extensions\nexport const INPUT_VIDEO_EXTENSIONS = [\n  \".mov\",\n  \".mp4\",\n  \".avi\",\n  \".mkv\",\n  \".mpg\",\n  \".webm\",\n  \".ts\",\n  \".mpeg\",\n  \".vob\",\n  \".m2ts\",\n  \".mts\",\n  \".m4v\",\n  \".flv\",\n  \".3gp\",\n  \".asf\",\n  \".wmv\",\n  \".rmvb\",\n  \".ogv\",\n  \".mxf\",\n  \".nut\",\n  \".dv\",\n  \".gxf\",\n  \".rm\",\n  \".cdxl\",\n  \".wtv\",\n  \".m3u8\",\n  \".mpd\",\n  \".seg\",\n  \".txd\",\n] as const;\nexport const INPUT_IMAGE_EXTENSIONS = [\n  \".jpg\",\n  \".jpeg\",\n  \".png\",\n  \".webp\",\n  \".heic\",\n  \".tiff\",\n  \".tif\",\n  \".avif\",\n  \".bmp\",\n  \".pcx\",\n  \".tga\",\n  \".ras\",\n  \".sgi\",\n  \".ppm\",\n  \".pgm\",\n  \".pbm\",\n  \".pnm\",\n  \".xbm\",\n  \".xpm\",\n  \".ico\",\n  \".jp2\",\n  \".j2k\",\n  \".pcd\",\n  \".cin\",\n  \".wbmp\",\n  \".xface\",\n] as const;\nexport const INPUT_AUDIO_EXTENSIONS = [\n  \".mp3\",\n  \".aac\",\n  \".wav\",\n  \".m4a\",\n  \".flac\",\n  \".aif\",\n  \".aiff\",\n  \".ogg\",\n  \".oga\",\n  \".alac\",\n  \".wma\",\n  \".opus\",\n  \".amr\",\n  \".caf\",\n  \".au\",\n  \".snd\",\n  \".ape\",\n  \".dsf\",\n  \".dff\",\n  \".mpc\",\n  \".wv\",\n  \".spx\",\n  \".xa\",\n  \".ra\",\n] as const;\n\nexport const OUTPUT_VIDEO_EXTENSIONS = [\".mp4\", \".avi\", \".mov\", \".mkv\", \".mpg\", \".webm\"] as const;\nexport const OUTPUT_AUDIO_EXTENSIONS = [\".mp3\", \".aac\", \".wav\", \".flac\", \".m4a\"] as const;\nexport const OUTPUT_IMAGE_EXTENSIONS = [\".jpg\", \".png\", \".webp\", \".heic\", \".tiff\", \".avif\"] as const;\n\nexport const INPUT_ALL_EXTENSIONS = [\n  ...INPUT_VIDEO_EXTENSIONS,\n  ...INPUT_IMAGE_EXTENSIONS,\n  ...INPUT_AUDIO_EXTENSIONS,\n] as const;\n\nexport const OUTPUT_ALL_EXTENSIONS = [\n  ...OUTPUT_VIDEO_EXTENSIONS,\n  ...OUTPUT_AUDIO_EXTENSIONS,\n  ...OUTPUT_IMAGE_EXTENSIONS,\n] as const;\n\n// =============================================================================\n// Media Type Definitions\n// =============================================================================\n\nexport type MediaType = \"image\" | \"audio\" | \"video\";\n\nexport type InputVideoExtension = (typeof INPUT_VIDEO_EXTENSIONS)[number];\nexport type InputImageExtension = (typeof INPUT_IMAGE_EXTENSIONS)[number];\nexport type InputAudioExtension = (typeof INPUT_AUDIO_EXTENSIONS)[number];\n\nexport type OutputVideoExtension = (typeof OUTPUT_VIDEO_EXTENSIONS)[number];\nexport type OutputImageExtension = (typeof OUTPUT_IMAGE_EXTENSIONS)[number];\nexport type OutputAudioExtension = (typeof OUTPUT_AUDIO_EXTENSIONS)[number];\n\nexport type AllOutputExtension = (typeof OUTPUT_ALL_EXTENSIONS)[number];\n\n// =============================================================================\n// Image Quality Settings\n// =============================================================================\n\nexport type ImageQuality = {\n  \".jpg\": Percentage;\n  \".png\": \"png-24\" | \"png-8\";\n  \".webp\": Percentage | \"lossless\";\n  \".heic\": Percentage;\n  \".tiff\": \"deflate\" | \"lzw\";\n  \".avif\": Percentage;\n};\n\n// =============================================================================\n// Audio Quality Settings\n// =============================================================================\n\nexport const AUDIO_BITRATES = [\"64\", \"96\", \"128\", \"160\", \"192\", \"224\", \"256\", \"320\"] as const;\nexport type AudioBitrate = (typeof AUDIO_BITRATES)[number];\nexport const AUDIO_SAMPLE_RATES = [\"22050\", \"44100\", \"48000\", \"96000\"] as const;\nexport type AudioSampleRate = (typeof AUDIO_SAMPLE_RATES)[number];\nexport const AUDIO_BIT_DEPTH = [\"16\", \"24\", \"32\"] as const;\nexport type AudioBitDepth = (typeof AUDIO_BIT_DEPTH)[number];\nexport const AUDIO_PROFILES = [\"aac_low\", \"aac_he\", \"aac_he_v2\"] as const;\nexport type AudioProfile = (typeof AUDIO_PROFILES)[number];\nexport const AUDIO_COMPRESSION_LEVEL = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"] as const;\nexport type AudioCompressionLevel = (typeof AUDIO_COMPRESSION_LEVEL)[number];\n\nexport type AudioControlType = \"bitrate\" | \"vbr\" | \"profile\" | \"sampleRate\" | \"bitDepth\" | \"compressionLevel\";\n\nexport type AudioQuality = {\n  \".mp3\": { bitrate: AudioBitrate; vbr?: boolean };\n  \".aac\": { bitrate: AudioBitrate; profile?: AudioProfile };\n  \".m4a\": AudioQuality[\".aac\"];\n  \".wav\": { sampleRate: AudioSampleRate; bitDepth: AudioBitDepth };\n  \".flac\": {\n    compressionLevel: AudioCompressionLevel;\n    sampleRate: AudioSampleRate;\n    bitDepth: \"16\" | \"24\";\n  };\n};\n\n// =============================================================================\n// Video Quality Settings\n// =============================================================================\n\nexport const VIDEO_ENCODING_MODES = [\"crf\", \"vbr\", \"vbr-2-pass\"] as const;\nexport type VideoEncodingMode = (typeof VIDEO_ENCODING_MODES)[number];\nexport type VideoCrf = Percentage; // 0-100 for user-friendly quality (converted to FFmpeg CRF 0-51 internally)\nexport const VIDEO_BITRATE = [\n  \"50000\",\n  \"40000\",\n  \"30000\",\n  \"25000\",\n  \"20000\",\n  \"15000\",\n  \"10000\",\n  \"8000\",\n  \"5000\",\n  \"4000\",\n  \"3000\",\n  \"2000\",\n  \"1500\",\n  \"1000\",\n  \"750\",\n  \"500\",\n] as const;\nexport type VideoBitrate = (typeof VIDEO_BITRATE)[number];\nexport const VIDEO_MAX_BITRATE = [\"\", ...VIDEO_BITRATE] as const;\nexport type VideoMaxBitrate = (typeof VIDEO_MAX_BITRATE)[number];\nexport const VIDEO_PRESET = [\n  \"veryslow\",\n  \"slower\",\n  \"slow\",\n  \"medium\",\n  \"fast\",\n  \"faster\",\n  \"veryfast\",\n  \"superfast\",\n  \"ultrafast\",\n] as const;\nexport type VideoPreset = (typeof VIDEO_PRESET)[number];\nexport const PRORES_VARIANTS = [\"4444xq\", \"4444\", \"hq\", \"standard\", \"lt\", \"proxy\"] as const;\nexport type ProResVariant = (typeof PRORES_VARIANTS)[number];\nexport const VP9_QUALITY = [\"best\", \"good\", \"realtime\"] as const;\nexport type VP9Quality = (typeof VP9_QUALITY)[number];\n\nexport type VideoControlType =\n  | \"encodingMode\"\n  | \"crf\"\n  | \"vbr\"\n  | \"vbr-2-pass\"\n  | \"bitrate\"\n  | \"maxBitrate\"\n  | \"preset\"\n  | \"quality\"\n  | \"variant\";\n\nexport type VideoQuality = {\n  \".mp4\":\n    | { encodingMode: \"crf\"; crf: VideoCrf; preset: VideoPreset }\n    | { encodingMode: \"vbr\" | \"vbr-2-pass\"; bitrate: VideoBitrate; maxBitrate: VideoMaxBitrate; preset: VideoPreset };\n  \".avi\":\n    | { encodingMode: \"crf\"; crf: VideoCrf }\n    | { encodingMode: \"vbr\" | \"vbr-2-pass\"; bitrate: VideoBitrate; maxBitrate: VideoMaxBitrate };\n  \".mov\": { variant: ProResVariant };\n  \".mkv\":\n    | { encodingMode: \"crf\"; crf: VideoCrf; preset: VideoPreset }\n    | { encodingMode: \"vbr\" | \"vbr-2-pass\"; bitrate: VideoBitrate; maxBitrate: VideoMaxBitrate; preset: VideoPreset };\n  \".mpg\":\n    | { encodingMode: \"crf\"; crf: VideoCrf }\n    | { encodingMode: \"vbr\" | \"vbr-2-pass\"; bitrate: VideoBitrate; maxBitrate: VideoMaxBitrate };\n  \".webm\":\n    | { encodingMode: \"crf\"; crf: VideoCrf; quality: VP9Quality }\n    | { encodingMode: \"vbr\" | \"vbr-2-pass\"; bitrate: VideoBitrate; maxBitrate: VideoMaxBitrate; quality: VP9Quality };\n};\n\n// =============================================================================\n// Universal Quality Type\n// =============================================================================\n\nexport type QualitySettings = ImageQuality | AudioQuality | VideoQuality;\nexport type AllControlType = VideoControlType | AudioControlType | \"qualityLevel\";\n\n// =============================================================================\n// Simple Quality Level Mappings\n// =============================================================================\n\nexport const SIMPLE_QUALITY_MAPPINGS = {\n  // Audio quality mappings\n  \".mp3\": {\n    lowest: { bitrate: \"96\", vbr: false },\n    low: { bitrate: \"128\", vbr: false },\n    medium: { bitrate: \"192\", vbr: true },\n    high: { bitrate: \"256\", vbr: true },\n    highest: { bitrate: \"320\", vbr: true },\n  },\n  \".aac\": {\n    lowest: { bitrate: \"96\", profile: \"aac_low\" },\n    low: { bitrate: \"128\", profile: \"aac_low\" },\n    medium: { bitrate: \"192\", profile: \"aac_low\" },\n    high: { bitrate: \"256\", profile: \"aac_low\" },\n    highest: { bitrate: \"320\", profile: \"aac_low\" },\n  },\n  \".m4a\": {\n    lowest: { bitrate: \"96\", profile: \"aac_low\" },\n    low: { bitrate: \"128\", profile: \"aac_low\" },\n    medium: { bitrate: \"192\", profile: \"aac_low\" },\n    high: { bitrate: \"256\", profile: \"aac_low\" },\n    highest: { bitrate: \"320\", profile: \"aac_low\" },\n  },\n  \".wav\": {\n    lowest: { sampleRate: \"22050\", bitDepth: \"16\" },\n    low: { sampleRate: \"44100\", bitDepth: \"16\" },\n    medium: { sampleRate: \"44100\", bitDepth: \"16\" },\n    high: { sampleRate: \"48000\", bitDepth: \"24\" },\n    highest: { sampleRate: \"96000\", bitDepth: \"24\" },\n  },\n  \".flac\": {\n    lowest: { compressionLevel: \"8\", sampleRate: \"44100\", bitDepth: \"16\" },\n    low: { compressionLevel: \"5\", sampleRate: \"44100\", bitDepth: \"16\" },\n    medium: { compressionLevel: \"5\", sampleRate: \"44100\", bitDepth: \"16\" },\n    high: { compressionLevel: \"3\", sampleRate: \"48000\", bitDepth: \"24\" },\n    highest: { compressionLevel: \"0\", sampleRate: \"96000\", bitDepth: \"24\" },\n  },\n\n  // Video quality mappings\n  \".mp4\": {\n    lowest: { encodingMode: \"crf\", crf: 30, preset: \"fast\" },\n    low: { encodingMode: \"crf\", crf: 50, preset: \"medium\" },\n    medium: { encodingMode: \"crf\", crf: 75, preset: \"medium\" },\n    high: { encodingMode: \"crf\", crf: 85, preset: \"slow\" },\n    highest: { encodingMode: \"crf\", crf: 95, preset: \"slower\" },\n  },\n  \".avi\": {\n    lowest: { encodingMode: \"crf\", crf: 30 },\n    low: { encodingMode: \"crf\", crf: 50 },\n    medium: { encodingMode: \"crf\", crf: 75 },\n    high: { encodingMode: \"crf\", crf: 85 },\n    highest: { encodingMode: \"crf\", crf: 95 },\n  },\n  \".mov\": {\n    lowest: { variant: \"proxy\" },\n    low: { variant: \"lt\" },\n    medium: { variant: \"standard\" },\n    high: { variant: \"hq\" },\n    highest: { variant: \"4444\" },\n  },\n  \".mkv\": {\n    lowest: { encodingMode: \"crf\", crf: 30, preset: \"fast\" },\n    low: { encodingMode: \"crf\", crf: 50, preset: \"medium\" },\n    medium: { encodingMode: \"crf\", crf: 75, preset: \"medium\" },\n    high: { encodingMode: \"crf\", crf: 85, preset: \"slow\" },\n    highest: { encodingMode: \"crf\", crf: 95, preset: \"slower\" },\n  },\n  \".mpg\": {\n    lowest: { encodingMode: \"crf\", crf: 30 },\n    low: { encodingMode: \"crf\", crf: 50 },\n    medium: { encodingMode: \"crf\", crf: 75 },\n    high: { encodingMode: \"crf\", crf: 85 },\n    highest: { encodingMode: \"crf\", crf: 95 },\n  },\n  \".webm\": {\n    lowest: { encodingMode: \"crf\", crf: 30, quality: \"realtime\" },\n    low: { encodingMode: \"crf\", crf: 50, quality: \"good\" },\n    medium: { encodingMode: \"crf\", crf: 60, quality: \"good\" },\n    high: { encodingMode: \"crf\", crf: 75, quality: \"good\" },\n    highest: { encodingMode: \"crf\", crf: 90, quality: \"best\" },\n  },\n} as const;\n\nexport const DEFAULT_SIMPLE_QUALITY: QualityLevel = \"high\";\n\n// =============================================================================\n// Default Quality Settings\n// =============================================================================\n\nexport const DEFAULT_QUALITIES = {\n  // Image defaults\n  \".jpg\": 80,\n  \".png\": \"png-24\",\n  \".webp\": 80,\n  \".heic\": 80,\n  \".tiff\": \"deflate\",\n  \".avif\": 80,\n\n  // Audio defaults\n  \".mp3\": { bitrate: \"192\", vbr: true },\n  \".aac\": { bitrate: \"192\", profile: \"aac_low\" },\n  \".m4a\": { bitrate: \"192\", profile: \"aac_low\" },\n  \".wav\": { sampleRate: \"44100\", bitDepth: \"16\" },\n  \".flac\": {\n    compressionLevel: \"5\",\n    sampleRate: \"44100\",\n    bitDepth: \"16\",\n  },\n\n  // Video defaults (CRF mode)\n  \".mp4\": { encodingMode: \"crf\", crf: 75, preset: \"medium\" },\n  \".avi\": { encodingMode: \"crf\", crf: 75 },\n  \".mov\": { variant: \"standard\" },\n  \".mkv\": { encodingMode: \"crf\", crf: 75, preset: \"medium\" },\n  \".mpg\": { encodingMode: \"crf\", crf: 75 },\n  \".webm\": { encodingMode: \"crf\", crf: 60, quality: \"good\" },\n} as const;\n\n// Video VBR defaults (for when switching to VBR modes)\nexport const DEFAULT_VBR_QUALITIES = {\n  \".mp4\": { encodingMode: \"vbr\", bitrate: \"2000\", maxBitrate: \"\", preset: \"medium\" },\n  \".avi\": { encodingMode: \"vbr\", bitrate: \"2000\", maxBitrate: \"\" },\n  \".mkv\": { encodingMode: \"vbr\", bitrate: \"2000\", maxBitrate: \"\", preset: \"medium\" },\n  \".mpg\": { encodingMode: \"vbr\", bitrate: \"2000\", maxBitrate: \"\" },\n  \".webm\": { encodingMode: \"vbr\", bitrate: \"2000\", maxBitrate: \"\", quality: \"good\" },\n} as const;\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\nexport function getMediaType(extension: string): MediaType | null {\n  extension = extension.toLowerCase();\n  if (INPUT_IMAGE_EXTENSIONS.includes(extension as InputImageExtension)) return \"image\";\n  if (INPUT_AUDIO_EXTENSIONS.includes(extension as InputAudioExtension)) return \"audio\";\n  if (INPUT_VIDEO_EXTENSIONS.includes(extension as InputVideoExtension)) return \"video\";\n  return null;\n}\n\ntype SimpleQualityMappingExtension = keyof typeof SIMPLE_QUALITY_MAPPINGS;\n\nexport function getDefaultQuality(\n  format: AllOutputExtension,\n  preferences: PreferenceValues,\n  qualityLevel?: QualityLevel,\n): QualitySettings {\n  // For images or when advanced settings are enabled, use DEFAULT_QUALITIES\n  if (!preferences) {\n    throw new Error(`fn getDefaultQuality: Provide preferences`);\n  }\n\n  if (getMediaType(format) === \"image\" || preferences.moreConversionSettings) {\n    return {\n      [format]: DEFAULT_QUALITIES[format],\n    } as QualitySettings;\n  }\n\n  if (!qualityLevel) {\n    throw new Error(`fn getDefaultQuality: Simple quality mapping is true, provide qualityLevel`);\n  }\n\n  if ((format as SimpleQualityMappingExtension) in SIMPLE_QUALITY_MAPPINGS) {\n    return {\n      [format]: SIMPLE_QUALITY_MAPPINGS[format as SimpleQualityMappingExtension][qualityLevel],\n    } as QualitySettings;\n  }\n\n  throw new Error(`Unsupported format for simple quality mapping: ${format}`);\n}\n"],
  "mappings": "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AAO,CACd,eAAQ,MAAM,8BAA+BA,CAAK,EAC3C,IACT,CACF,CEjLO,IAAMgB,GAAyB,CACpC,OACA,OACA,OACA,OACA,OACA,QACA,MACA,QACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,MACA,OACA,MACA,QACA,OACA,QACA,OACA,OACA,MACF,EACaC,GAAyB,CACpC,OACA,QACA,OACA,QACA,QACA,QACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACF,EACaC,GAAyB,CACpC,OACA,OACA,OACA,OACA,QACA,OACA,QACA,OACA,OACA,QACA,OACA,QACA,OACA,OACA,MACA,OACA,OACA,OACA,OACA,OACA,MACA,OACA,MACA,KACF,EAEaC,GAA0B,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAO,EAC1EC,GAA0B,CAAC,OAAQ,OAAQ,OAAQ,QAAS,MAAM,EAClEC,GAA0B,CAAC,OAAQ,OAAQ,QAAS,QAAS,QAAS,OAAO,EAE7EC,GAAuB,CAClC,GAAGN,GACH,GAAGC,GACH,GAAGC,EACL,EAEaK,GAAwB,CACnC,GAAGJ,GACH,GAAGC,GACH,GAAGC,EACL,EAmCaG,EAAiB,CAAC,KAAM,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,EAEtEC,EAAqB,CAAC,QAAS,QAAS,QAAS,OAAO,EAExDC,GAAkB,CAAC,KAAM,KAAM,IAAI,EAEnCC,GAAiB,CAAC,UAAW,SAAU,WAAW,EAElDC,GAA0B,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAqBtEC,EAAuB,CAAC,MAAO,MAAO,YAAY,EAGlDC,EAAgB,CAC3B,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,KACF,EAEaC,EAAoB,CAAC,GAAI,GAAGD,CAAa,EAEzCE,EAAe,CAC1B,WACA,SACA,OACA,SACA,OACA,SACA,WACA,YACA,WACF,E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",
  "names": ["convert_media_exports", "__export", "confirmation", "ConvertMedia", "__toCommonJS", "import_path", "import_fs", "import_os", "import_fs", "import_os", "import_api", "import_util", "import_child_process", "execPromise", "util", "checkFFmpegVersion", "ffmpegPath", "stdout", "execPromise", "versionMatch", "major", "minor", "error", "findFFmpegPath", "minimumVersion", "customPath", "fs", "version", "storedPath", "platform", "os", "commonPaths", "programFiles", "programFilesX86", "userProfile", "localAppData", "homeDir", "path", "INPUT_VIDEO_EXTENSIONS", "INPUT_IMAGE_EXTENSIONS", "INPUT_AUDIO_EXTENSIONS", "OUTPUT_VIDEO_EXTENSIONS", "OUTPUT_AUDIO_EXTENSIONS", "OUTPUT_IMAGE_EXTENSIONS", "INPUT_ALL_EXTENSIONS", "OUTPUT_ALL_EXTENSIONS", "AUDIO_BITRATES", "AUDIO_SAMPLE_RATES", "AUDIO_BIT_DEPTH", "AUDIO_PROFILES", "AUDIO_COMPRESSION_LEVEL", "VIDEO_ENCODING_MODES", "VIDEO_BITRATE", "VIDEO_MAX_BITRATE", "VIDEO_PRESET", "PRORES_VARIANTS", "VP9_QUALITY", "SIMPLE_QUALITY_MAPPINGS", "DEFAULT_QUALITIES", "getMediaType", "extension", "INPUT_IMAGE_EXTENSIONS", "INPUT_AUDIO_EXTENSIONS", "INPUT_VIDEO_EXTENSIONS", "convertQualityToCrf", "qualityPercentage", "getUniqueOutputPath", "filePath", "extension", "outputFilePath", "path", "finalOutputPath", "counter", "fs", "fileName", "dirName", "convertMedia", "outputFormat", "quality", "ffmpegPath", "findFFmpegPath", "ffmpegCmd", "getMediaType", "currentOutputFormat", "imageQuality", "tempHeicFile", "tempPaletteFile", "processedInputPath", "execPromise", "error", "errorMessage", "tempFileName", "os", "tempPaletteFileName", "audioQuality", "mp3Settings", "aacSettings", "m4aSettings", "wavSettings", "flacSettings", "videoQuality", "mp4Quality", "movQuality", "mkvQuality", "webmQuality", "logFilePrefix", "qualitySettings", "nullDevice", "firstPassCmd", "logFiles", "logFile", "fileError", "import_path", "import_os", "import_fs", "getFullPath", "inputPath", "fullPath", "path", "os", "fs", "ConvertMedia", "input", "outputFileType", "quality", "imageQualityPercent", "webpLossless", "pngVariant", "tiffCompression", "audioBitrate", "audioVbr", "audioProfile", "audioSampleRate", "audioBitDepth", "flacCompressionLevel", "videoEncodingMode", "videoCrf", "videoBitrate", "videoMaxBitrate", "videoPreset", "proresVariant", "vp9Quality", "findFFmpegPath", "mediaType", "getMediaType", "error", "outputPath", "qualitySettings", "baseDefault", "DEFAULT_QUALITIES", "current", "value", "pct", "clampPercent", "audioValue", "SIMPLE_QUALITY_MAPPINGS", "validateOneOf", "AUDIO_BITRATES", "fallbackProfile", "AUDIO_PROFILES", "AUDIO_SAMPLE_RATES", "AUDIO_BIT_DEPTH", "bitDepth", "AUDIO_COMPRESSION_LEVEL", "videoValue", "PRORES_VARIANTS", "mode", "VIDEO_ENCODING_MODES", "currentCrf", "VP9_QUALITY", "VIDEO_BITRATE", "VIDEO_MAX_BITRATE", "currentPreset", "VIDEO_PRESET", "convertMedia", "settingsSummary", "summarizeSettings", "confirmation", "params", "message", "info", "advSummary", "summarizeParams", "allowed", "fallback", "img", "v", "aud", "vid", "parts"]
}
